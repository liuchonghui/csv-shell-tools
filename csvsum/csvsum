#!/bin/bash

# 脚本名称：csvsum
# 功能：计算CSV文件指定列（或所有列）的数值累加和（优化输出格式，方便awk分析）
# 用法：csvsum [--col=列号[,列号...]|--col=all] 文件路径

# 初始化变量
COLUMNS=""
CSV_FILE=""

# 函数：打印用法说明
print_usage() {
    echo "用法: $0 [--col=列号[,列号...]|--col=all] CSV文件路径"
    echo "示例:"
    echo "  $0 --col=9 data.csv          # 计算第9列的累加和"
    echo "  $0 --col=9,10,11 data.csv   # 计算第9、10、11列的累加和"
    echo "  $0 --col=all data.csv       # 计算所有列的累加和"
    echo "  $0 data.csv                 # 默认计算所有列的累加和"
}

# 函数：校验文件是否为CSV文件
check_csv_file() {
    local file="$1"
    # 检查文件是否存在
    if [ ! -f "$file" ]; then
        echo "错误：文件 '$file' 不存在！"
        exit 1
    fi
    # 检查文件后缀是否为.csv（不区分大小写）
    if [[ "$file" != *.csv && "$file" != *.CSV ]]; then
        echo "错误：文件 '$file' 不是CSV文件！"
        exit 1
    fi
    # 检查文件是否可读
    if [ ! -r "$file" ]; then
        echo "错误：文件 '$file' 不可读取！"
        exit 1
    fi
    # 检查文件是否为空
    if [ ! -s "$file" ]; then
        echo "错误：文件 '$file' 是空文件！"
        exit 1
    fi
}

# 函数：获取CSV文件的总列数（修复：清理首行不可见字符、末尾空格、BOM头）
get_total_columns() {
    local csv_file="$1"
    # 1. 读取首行 2. 移除BOM头（UTF-8 BOM） 3. 移除末尾所有空格/制表符 4. 移除换行符
    local first_line=$(head -n 1 "$csv_file" | sed -e 's/^\xef\xbb\xbf//' -e 's/[[:space:]]*$//' | tr -d '\n')
    # 按逗号分割统计列数（即使最后一位是逗号，也过滤掉空列）
    echo "$first_line" | awk -F ',' '
    {
        # 统计非空列数（过滤掉末尾逗号导致的空列）
        count = 0;
        for (i=1; i<=NF; i++) {
            if ($i != "") {
                count++;
            }
        }
        print count;
    }'
}

# 函数：计算指定列的累加和（强化：兼容各种空格、不可见字符；优化输出格式）
calculate_sum() {
    local col_num="$1"
    local csv_file="$2"
    
    # 获取列名（修复：清理BOM头、空格）
    col_name=$(head -n 1 "$csv_file" | sed -e 's/^\xef\xbb\xbf//' -e 's/[[:space:]]*$//' | awk -F ',' -v col="$col_num" '{print $col}')
    # 处理空列名
    if [ -z "$col_name" ]; then
        col_name="未命名列"
    fi
    # 清理列名中的多余空格
    col_name=$(echo "$col_name" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

    # 计算数据行数（总行数-1，排除首行）
    total_lines=$(wc -l < "$csv_file")
    data_lines=$((total_lines - 1))
    # 处理只有首行的情况
    if [ "$data_lines" -le 0 ]; then
        # 优化输出格式：第 0 列 未命名列 0 个数据的累加总和为 0
        echo "第 $col_num 列 $col_name $data_lines 个数据的累加总和为 0"
        return
    fi

    # 核心计算逻辑（修复：清理数值中的空格、兼容浮点型）
    sum=$(tail -n +2 "$csv_file" | awk -F ',' -v col="$col_num" '
    BEGIN {
        total = 0.0; # 显式声明为浮点型，保证数值精度
    }
    {
        # 1. 获取列值 2. 清理前后空格 3. 处理列号超出当前行列数的情况
        val = (col <= NF) ? $col : "";
        val = gensub(/^[[:space:]]*|[[:space:]]*$/, "", "g", val);
        
        # 严格判断：空值/非数字（含字母、符号）均按0处理
        # 支持：整数、小数、正负数值（如 -123.45、+67.89）
        if (val == "" || val !~ /^[+-]?[0-9]*\.?[0-9]+$/) {
            val = 0;
        }
        total += val;
    }
    END {
        print total;
    }')

    # 核心修改：优化输出格式，在指定位置添加空格
    # 原格式：第${col_num}列 ${col_name} ${data_lines}个数据的累加总和为${sum}
    # 新格式：第 $col_num 列 $col_name $data_lines 个数据的累加总和为 $sum
    echo "第 $col_num 列 $col_name $data_lines 个数据的累加总和为 $sum"
}

# 解析参数
if [ $# -eq 0 ]; then
    echo "错误：缺少必要的文件路径参数！"
    print_usage
    exit 1
fi

# 遍历参数（最后一个参数是文件路径，其余是可选参数）
total_args=$#
arg_index=1
for arg in "$@"; do
    if [ $arg_index -eq $total_args ]; then
        # 最后一个参数：文件路径
        CSV_FILE="$arg"
        check_csv_file "$CSV_FILE"
    else
        # 可选参数：--col
        if [[ "$arg" == --col=* ]]; then
            COLUMNS="${arg#--col=}"
            # 校验列参数格式（all 或 数字+逗号）
            if [[ "$COLUMNS" != "all" && ! "$COLUMNS" =~ ^[0-9,]+$ ]]; then
                echo "错误：--col参数格式错误，应为 --col=列号[,列号...] 或 --col=all"
                print_usage
                exit 1
            fi
        else
            echo "错误：不支持的参数 '$arg'！"
            print_usage
            exit 1
        fi
    fi
    arg_index=$((arg_index + 1))
done

echo $CSV_FILE

# 处理默认行为（未指定--col时，等价于--col=all）
if [ -z "$COLUMNS" ]; then
    COLUMNS="all"
fi

# 处理--col=all的情况：生成1到总列数的列号列表
if [ "$COLUMNS" = "all" ]; then
    total_cols=$(get_total_columns "$CSV_FILE")
    # 防止总列数为0的异常
    if [ "$total_cols" -eq 0 ]; then
        echo "错误：CSV文件无有效列！"
        exit 1
    fi
    # 生成 1,2,3,...,total_cols 格式的字符串
    COLUMNS=$(seq -s ',' 1 $total_cols)
fi

# 拆分列号并逐个计算（修复：过滤空列号）
IFS=',' read -ra COL_ARRAY <<< "$COLUMNS"
for col in "${COL_ARRAY[@]}"; do
    # 清理列号中的空格
    col=$(echo "$col" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    # 校验列号是否为正整数
    if ! [[ "$col" =~ ^[1-9][0-9]*$ ]]; then
        echo "错误：列号 '$col' 无效，必须是正整数！"
        exit 1
    fi
    # 计算当前列的累加和
    calculate_sum "$col" "$CSV_FILE"
done

exit 0